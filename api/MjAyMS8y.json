{"title":"JavaScript函数自调用与闭包","date":"2021-10-25T12:19:00.000Z","date_formatted":{"ll":"Oct 25, 2021","L":"10/25/2021","MM-DD":"10-25"},"link":"2021/2","comments":true,"tags":["javascript"],"categories":["programming"],"updated":"2022-03-14T08:42:54.000Z","content":"<p>简单的说，javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。</p>\n<span id=\"more\"></span>\n<h1 id=\"闭包\">闭包<a title=\"#闭包\" href=\"#闭包\"></a></h1>\n<p>要理解闭包，我们要了解栈堆内存和作用域链。</p>\n<h2 id=\"栈堆内存\">栈堆内存<a title=\"#栈堆内存\" href=\"#栈堆内存\"></a></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a= 2;</span><br><span class=\"line\">var c=&#123;&quot;ani&quot;:&quot;老虎&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>1.上面的两行代码做的事就是在栈内存中定义了一个变量a和一个变量c。</p>\n<p>2.变量a指向的值为2，变量c指向的值为一个地址，这个地址又指向堆内存空间的{“ani”:“老虎”}。</p>\n<p>3.因为在javascript中基本数据类型是存储在栈内存中的，引用数据类型是存储在堆内存中的。看表</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>栈内存</th>\n<th>栈内存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>变量</td>\n<td>值</td>\n</tr>\n<tr>\n<td>a</td>\n<td>2</td>\n</tr>\n<tr>\n<td>c</td>\n<td>引用地址</td>\n</tr>\n</tbody>\n</table></div></div><h2 id=\"作用域链\">作用域链<a title=\"#作用域链\" href=\"#作用域链\"></a></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function fc()&#123;</span><br><span class=\"line\">    var b = 2;</span><br><span class=\"line\">    function fc1()&#123;</span><br><span class=\"line\">        console.log(b);//2</span><br><span class=\"line\">        console.log(a);//1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fc1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fc(); </span><br></pre></td></tr></table></figure>\n<p>在这个代码中我们先看</p>\n<p>fc1在栈内的执行</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody>\n</table></div></div><p>fc的执行</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n<td>2</td>\n</tr>\n<tr>\n<td>fc1</td>\n<td>引用地址</td>\n</tr>\n</tbody>\n</table></div></div><p>全局执行</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>1</td>\n</tr>\n<tr>\n<td>fc</td>\n<td>引用地址</td>\n</tr>\n</tbody>\n</table></div></div><p>1.var a=1；这个时候我们是在全局执行环境的，浏览器的全局环境就是window作用域，我们的window作用域中有a和fc；</p>\n<p>2.当我们往下走到fc的时候，栈内存会开辟一块新的执行环境，此时fc的执行环境中我们有b和fc1；</p>\n<p>3.当我们接着往下走到fc1的时候，这时栈内存同样会开辟一块新的执行环境，此时fc1的执行环境中是没有任何变量数据的，但是我们在fc1中输出a、b，我们都是可以读取到的；这是因为程序在读取变量的时候是从内到外的开始读的，是随着fc1开始往上一层一层的查找，是这样的执行顺序(fc1 = &gt; fc = &gt; window)，如果找到window中还没有读取到变量，这时程序才会报错；</p>\n<p>当然在执行的过程中，垃圾回收机制如果检测到程序执行完了是会进行垃圾回收的，避免造成内存泄露等问题；就是说我们的fc1里面执行完之后fc1的作用域就会被销毁，接着程序执行fc，fc执行完之后fc就会被销毁；往上执行到全局的时候，整个程序就没有了fc的作用域和fc1的作用域，只剩下浏览器的全局作用域window，这个时候window里只剩a和fc；</p>\n<h2 id=\"闭包-1\">闭包<a title=\"#闭包-1\" href=\"#闭包-1\"></a></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function outer() &#123;</span><br><span class=\"line\">     var  a = &#x27;123&#x27;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return function add()&#123;　　　　//在这里因为作用域的关系，add是能访问到outer的所有变量的，但是outer是访问不到add的变量；　　　　//所以思路一转，把add的值作为结果return出来变通实现outer外部函数访问到了内部函数变量</span><br><span class=\"line\">    // add就是一个闭包函数，因为他能够访问到outer函数的作用域，add中没有找到变量a，则会继续往上层作用域找</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var  inner = outer()   // 获得add闭包函数</span><br><span class=\"line\">inner()   //&quot;123&quot;</span><br></pre></td></tr></table></figure>\n<p>首先我们可以看到，在全局作用域下我们是有一个outer函数的，outer作用域里面有a和add，add作用域里面执行控制台输出a的变量，此时这里的add函数就形成了一个闭包，因为add函数里面需要访问到outer作用域下的a变量，而他们不处在同一个作用域中，所以两者相互牵引，需要输出a，上面outer中的变量a就必须得在，作用域链查找到outer的时候找到a了，输出a的时候，垃圾回收机制会认为add还没有执行完成，因为此时的作用域链查找已经到了outer作用域下，所以不会清理a的内存空间；所以这就会带来一个问题：如果我们多次的使用闭包，则会给我们的程序带来内存占用过多，导致性能问题；<br>\n函数内部能访问全局变量是javascript语言的特殊之处，但是如果我们想达到函数外部能访问内部变量的时候，我们就可以使用闭包，这就是闭包给我们带来的便利；</p>\n<p>闭包的优缺点：</p>\n<p>优点：</p>\n<p>1.可以读取函数内部的变量<br>\n2.可以避免全局污染</p>\n<p>缺点：</p>\n<p>1.闭包会导致变量不会被垃圾回收机制所清除，会大量消耗内存；</p>\n<p>2.不恰当的使用闭包可能会造成内存泄漏的问题；</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>1.作用域链查找变量的方式是一层一层的往上查找，直到找到为止，如果找到window全局作用域还未找到，就报undefined；</p>\n<p>2.嵌套函数中，因为不在同一作用域，正常情况下内外部函数是访问不到内部函数的，但是通过闭包可以实现；</p>\n<p>3.尽可能少的使用闭包，因为会造成内存消耗大以及有可能造成内存泄露（如果不需要的时候，不要随便使用）；</p>\n<h1 id=\"自调用匿名函数\">自调用匿名函数<a title=\"#自调用匿名函数\" href=\"#自调用匿名函数\"></a></h1>\n<p>形式1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(形参列表)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　return .....</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;)(实参列表);</span><br></pre></td></tr></table></figure>\n<p>形式2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(形参列表)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　return .....</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;(实参列表));</span><br></pre></td></tr></table></figure>\n<p>函数表达式调用法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exc=function()&#123;</span><br><span class=\"line\">    console.log(&quot;hello world&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exc();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>逐层调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun1()&#123;</span><br><span class=\"line\">    var a=0;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//注意这种调用的结果:</span><br><span class=\"line\">fun1();</span><br><span class=\"line\">fun1()();</span><br><span class=\"line\">fun1()();</span><br><span class=\"line\">输出</span><br><span class=\"line\">0</span><br><span class=\"line\">//</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">//</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">//解释:每一次先执行fun1(),a都会初始化为0,再执行匿名函数,a++得到1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>先赋值给一个变量再由变量调用:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun1()&#123;</span><br><span class=\"line\">    var a=0;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    return function()&#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//注意这种调用的结果:</span><br><span class=\"line\">var res=fun1();</span><br><span class=\"line\">res();</span><br><span class=\"line\">res();</span><br><span class=\"line\">res();</span><br><span class=\"line\">输出</span><br><span class=\"line\">0</span><br><span class=\"line\">//</span><br><span class=\"line\">1</span><br><span class=\"line\">//</span><br><span class=\"line\">2</span><br><span class=\"line\">//</span><br><span class=\"line\">3</span><br><span class=\"line\">//解释:fun1()只执行一次,所以a=0只执行一次,以后每次执行res()是在执行匿名函数,每执行一次,a自增一次</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","prev":{"title":"Thinkphp项目配置","link":"2022/thinkphpcfg"},"next":{"title":"使用termux+netlify+github+cloudflare搭建hexo+备份及恢复","link":"2021/termux"},"plink":"https://tgwl.github.io/2021/2/","toc":[{"id":"闭包","title":"闭包","index":"1","children":[{"id":"栈堆内存","title":"栈堆内存","index":"1.1"},{"id":"作用域链","title":"作用域链","index":"1.2"},{"id":"闭包-1","title":"闭包","index":"1.3"},{"id":"总结","title":"总结","index":"1.4"}]},{"id":"自调用匿名函数","title":"自调用匿名函数","index":"2"}],"reward":true,"copyright":{"author":"Zezin","link":"<a href=\"https://tgwl.github.io/2021/2/\" title=\"JavaScript函数自调用与闭包\">https://tgwl.github.io/2021/2/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}